// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"nominatim-go/ent/addressrow"
	"nominatim-go/ent/helloworld"
	"nominatim-go/ent/place"
)

const errInvalidPage = "INVALID_PAGE"

const (
	listField     = "list"
	pageNumField  = "pageNum"
	pageSizeField = "pageSize"
)

type PageDetails struct {
	Page  uint64 `json:"page"`
	Size  uint64 `json:"size"`
	Total uint64 `json:"total"`
}

// OrderDirection defines the directions in which to order a list of items.
type OrderDirection string

const (
	// OrderDirectionAsc specifies an ascending order.
	OrderDirectionAsc OrderDirection = "ASC"
	// OrderDirectionDesc specifies a descending order.
	OrderDirectionDesc OrderDirection = "DESC"
)

// Validate the order direction value.
func (o OrderDirection) Validate() error {
	if o != OrderDirectionAsc && o != OrderDirectionDesc {
		return fmt.Errorf("%s is not a valid OrderDirection", o)
	}
	return nil
}

// String implements fmt.Stringer interface.
func (o OrderDirection) String() string {
	return string(o)
}

func (o OrderDirection) reverse() OrderDirection {
	if o == OrderDirectionDesc {
		return OrderDirectionAsc
	}
	return OrderDirectionDesc
}

const errInvalidPagination = "INVALID_PAGINATION"

type AddressRowPager struct {
	// Order OrderFunc
	Order  addressrow.OrderOption
	Filter func(*AddressRowQuery) (*AddressRowQuery, error)
}

// AddressRowPaginateOption enables pagination customization.
type AddressRowPaginateOption func(*AddressRowPager)

// DefaultAddressRowOrder is the default ordering of AddressRow.
var DefaultAddressRowOrder = Desc(addressrow.FieldID)

func newAddressRowPager(opts []AddressRowPaginateOption) (*AddressRowPager, error) {
	pager := &AddressRowPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		//pager.Order = DefaultAddressRowOrder
	}
	return pager, nil
}

func (p *AddressRowPager) ApplyFilter(query *AddressRowQuery) (*AddressRowQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// AddressRowPageList is AddressRow PageList result.
type AddressRowPageList struct {
	List        []*AddressRow `json:"list"`
	PageDetails *PageDetails  `json:"pageDetails"`
}

func (_m *AddressRowQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, withCount bool, opts ...AddressRowPaginateOption,
) (*AddressRowPageList, error) {
	pager, err := newAddressRowPager(opts)
	if err != nil {
		return nil, err
	}

	if _m, err = pager.ApplyFilter(_m); err != nil {
		return nil, err
	}

	ret := &AddressRowPageList{}

	ret.PageDetails = &PageDetails{
		Page:  pageNum,
		Size:  pageSize,
		Total: 0,
	}

	if withCount {
		count, err := _m.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		ret.PageDetails.Total = uint64(count)
	}

	if pager.Order != nil {
		_m = _m.Order(pager.Order)
	} else {
		//_m = _m.Order(DefaultAddressRowOrder)
	}

	_m = _m.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type HelloworldPager struct {
	// Order OrderFunc
	Order  helloworld.OrderOption
	Filter func(*HelloworldQuery) (*HelloworldQuery, error)
}

// HelloworldPaginateOption enables pagination customization.
type HelloworldPaginateOption func(*HelloworldPager)

// DefaultHelloworldOrder is the default ordering of Helloworld.
var DefaultHelloworldOrder = Desc(helloworld.FieldID)

func newHelloworldPager(opts []HelloworldPaginateOption) (*HelloworldPager, error) {
	pager := &HelloworldPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		//pager.Order = DefaultHelloworldOrder
	}
	return pager, nil
}

func (p *HelloworldPager) ApplyFilter(query *HelloworldQuery) (*HelloworldQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// HelloworldPageList is Helloworld PageList result.
type HelloworldPageList struct {
	List        []*Helloworld `json:"list"`
	PageDetails *PageDetails  `json:"pageDetails"`
}

func (_m *HelloworldQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, withCount bool, opts ...HelloworldPaginateOption,
) (*HelloworldPageList, error) {
	pager, err := newHelloworldPager(opts)
	if err != nil {
		return nil, err
	}

	if _m, err = pager.ApplyFilter(_m); err != nil {
		return nil, err
	}

	ret := &HelloworldPageList{}

	ret.PageDetails = &PageDetails{
		Page:  pageNum,
		Size:  pageSize,
		Total: 0,
	}

	if withCount {
		count, err := _m.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		ret.PageDetails.Total = uint64(count)
	}

	if pager.Order != nil {
		_m = _m.Order(pager.Order)
	} else {
		//_m = _m.Order(DefaultHelloworldOrder)
	}

	_m = _m.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type PlacePager struct {
	// Order OrderFunc
	Order  place.OrderOption
	Filter func(*PlaceQuery) (*PlaceQuery, error)
}

// PlacePaginateOption enables pagination customization.
type PlacePaginateOption func(*PlacePager)

// DefaultPlaceOrder is the default ordering of Place.
var DefaultPlaceOrder = Desc(place.FieldID)

func newPlacePager(opts []PlacePaginateOption) (*PlacePager, error) {
	pager := &PlacePager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		//pager.Order = DefaultPlaceOrder
	}
	return pager, nil
}

func (p *PlacePager) ApplyFilter(query *PlaceQuery) (*PlaceQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// PlacePageList is Place PageList result.
type PlacePageList struct {
	List        []*Place     `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

func (_m *PlaceQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, withCount bool, opts ...PlacePaginateOption,
) (*PlacePageList, error) {
	pager, err := newPlacePager(opts)
	if err != nil {
		return nil, err
	}

	if _m, err = pager.ApplyFilter(_m); err != nil {
		return nil, err
	}

	ret := &PlacePageList{}

	ret.PageDetails = &PageDetails{
		Page:  pageNum,
		Size:  pageSize,
		Total: 0,
	}

	if withCount {
		count, err := _m.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		ret.PageDetails.Total = uint64(count)
	}

	if pager.Order != nil {
		_m = _m.Order(pager.Order)
	} else {
		//_m = _m.Order(DefaultPlaceOrder)
	}

	_m = _m.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}
